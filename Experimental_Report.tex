\documentclass[supercite]{Experimental_Report}

\title{~~~~~~数据结构实验~~~~~~}
\author{刘欣逸}
\school{计算机科学与技术学院}
\classnum{CS2210}
\stunum{U202115473}
\instructor{郑渤龙}
\date{2023年5月29日}


\usepackage{ctex}
\usepackage{listings}

\usepackage{algorithm, multirow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{xltxtra} %提供了针对XeTeX的改进并且加入了XeTeX的LOGO, 自动调用xunicode宏包(提供Unicode字符宏)
\usepackage{bm}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}
\usepackage{enumitem}

\usepackage{xcolor}
\definecolor{commentColor}{RGB}{53,129,34}
\definecolor{keywordColor}{RGB}{172, 62, 158}
\definecolor{stringColor}{RGB}{194, 62, 42}
\definecolor{preprocessorColor}{RGB}{114, 75, 48}
\definecolor{characterColor}{RGB}{31, 53, 207}
\definecolor{numberColor}{RGB}{166, 166, 166}
\definecolor{oglobalColor}{RGB}{97, 64, 154}
\definecolor{globalColor}{RGB}{89, 127, 134}
\definecolor{functionColor}{RGB}{56,36,124}

\usepackage{fontspec}
\newfontfamily\sfr{SFMono-Regular}
\newfontfamily\sfb{SFMono-Bold}

\usepackage{listings}
\lstset{
	language=C++,
	basicstyle=\sffamily\sfr,
	keywordstyle=\color{keywordColor}\sffamily\sfr,
	commentstyle=\color{commentColor}\sffamily\sfr,
	stringstyle=\color{stringColor}\sffamily\sfr,
	showstringspaces=false,
	columns=fullflexible,keepspaces,
	numbers=left,
	numberstyle=\color{numberColor}\footnotesize\sfr,
	escapechar=\$,
	morecomment=*[s][\color{stringColor}\sffamily\sfr]{<}{>},
	morecomment=[s][\color{characterColor}\sffamily\sfr]{'}{'},
	keywords=[2]{std, cout, cin},
	keywordstyle = [2]{\color{oglobalColor}\sffamily\sfr},
	keywords=[3]{endl, printf, scanf, setw, setfill, setbase, setprecision, time, ctime, rand},
	keywordstyle = [3]{\color{functionColor}\sffamily\sfr},
	keywords=[4]{\#include},
	keywordstyle =[4]{\color{preprocessorColor}\ssfamily\sfr},
	literate={
		{<<}{{{\color{black}<<}}}1
		{>>}{{{\color{black}>>}}}1
		{*}{{{*}}}1
		{0}{{{\color{characterColor}0}}}1
		{1}{{{\color{characterColor}1}}}1
		{2}{{{\color{characterColor}2}}}1
		{3}{{{\color{characterColor}3}}}1
		{4}{{{\color{characterColor}4}}}1
		{5}{{{\color{characterColor}5}}}1
		{6}{{{\color{characterColor}6}}}1
		{7}{{{\color{characterColor}7}}}1
		{8}{{{\color{characterColor}8}}}1
		{9}{{{\color{characterColor}9}}}1
		},
	tabsize=4,
	frame=single,
	frameround=tttt
}


\pgfplotsset{compat=1.16}

\newcommand{\cfig}[3]{
  \begin{figure}[htb]
    \centering
    \includegraphics[width=#2\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{figure}
}

\newcommand{\sfig}[3]{
  \begin{subfigure}[b]{#2\textwidth}
    \includegraphics[width=\textwidth]{images/#1.tikz}
    \caption{#3}
    \label{fig:#1}
  \end{subfigure}
}

\newcommand{\xfig}[3]{
  \begin{figure}[htb]
    \centering
    #3
    \caption{#2}
    \label{fig:#1}
  \end{figure}
}

\newcommand{\rfig}[1]{\autoref{fig:#1}}
\newcommand{\ralg}[1]{\autoref{alg:#1}}
\newcommand{\rthm}[1]{\autoref{thm:#1}}
\newcommand{\rlem}[1]{\autoref{lem:#1}}
\newcommand{\reqn}[1]{\autoref{eqn:#1}}
\newcommand{\rtbl}[1]{\autoref{tbl:#1}}

\algnewcommand\Null{\textsc{null }}
\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\Input{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Output{\item[\algorithmicoutput]}
\algnewcommand\algorithmicbreak{\textbf{break}}
\algnewcommand\Break{\algorithmicbreak}
\algnewcommand\algorithmiccontinue{\textbf{continue}}
\algnewcommand\Continue{\algorithmiccontinue}
\algnewcommand{\LeftCom}[1]{\State $\triangleright$ #1}

\newtheorem{thm}{定理}[section]
\newtheorem{lem}{引理}[section]

\colorlet{shadecolor}{black!15}

\theoremstyle{definition}
\newtheorem{alg}{算法}[section]

\def\thmautorefname~#1\null{定理~#1~\null}
\def\lemautorefname~#1\null{引理~#1~\null}
\def\algautorefname~#1\null{算法~#1~\null}

\begin{document}

\maketitle

\clearpage

\pagenumbering{Roman}

\tableofcontents[level=2]

\clearpage

\pagenumbering{arabic}

\section{基于顺序存储结构的线性表实现}


\subsection{问题描述}


要求构造一个具有菜单的功能演示系统。该演示系统实现多个线性表管理。其中，在主函数中准备函数调用所需实参值、显示函数执行结果，并给出适当的操作提示。

实现依据最小完备性和常用性相结合的原则确定的初始化表、销毁表、清空表、判定空表、求表长和获得元素等12种基本运算，具体运算功能定义如下。
\begin{enumerate}


	\item 初始化表：函数名称是\verb|InitaList(L)|；初始条件是线性表\verb|L|不存在已存在；操作结果是构造一个空的线性表。


	\item 销毁表：函数名称是\verb|DestroyList(L)|；初始条件是线性表\verb|L|已存在；操作结果是销毁线性表\verb|L|。


	\item 清空表：函数名称是\verb|ClearList(L)|；初始条件是线性表\verb|L|已存在；操作结果是将\verb|L|重置为空表。


	\item 判定空表：函数名称是\verb|ListEmpty(L)|；初始条件是线性表\verb|L|已存在；操作结果是若\verb|L|为空表则返回\verb|TRUE|,否则返回\verb|FALSE|。


	\item 求表长：函数名称是\verb|ListLength(L)|；初始条件是线性表\verb|L|已存在；操作结果是返回\verb|L|中数据元素的个数。


	\item 获得元素：函数名称是\verb|GetElem(L,i,e)|；初始条件是线性表\verb|L|已存在， \\ 1≤\verb|i|≤\verb|ListLength(L)|；操作结果是用\verb|e|返回\verb|L|中第\verb|i|个数据元素的值。


	\item 查找元素：函数名称是\verb|LocateElem(L,e,compare())|；初始条件是线性表\verb|L|已存在；操作结果是返回\verb|L|中第一个与\verb|e|满足关系\verb|compare()|关系的数据元素的位序，若这样的数据元素不存在，则返回值为\verb|0|。


	\item 获得前驱：函数名称是\verb|PriorElem(L,cur_e,pre_e)|；初始条件是线性表\verb|L|已存在；操作结果是若\verb|cur_e|是\verb|L|的数据元素，且不是第一个，则用\verb|pre_e|返回它的前驱，否则操作失败，\verb|pre_e|无定义。


	\item 获得后继：函数名称是\verb|NextElem(L,cur_e,next_e)|；初始条件是线性表\verb|L|已存在；操作结果是若\verb|cur_e|是\verb|L|的数据元素，且不是最后一个，则用\verb|next_e|返回它的后继，否则操作失败，\verb|next_e|无定义。


	\item 插入元素：函数名称是\verb|ListInsert(L,i,e)|；初始条件是线性表\verb|L|已存在，\\ 1≤\verb|i|≤\verb|ListLength(L)+1|；操作结果是在\verb|L|的第\verb|i|个位置之前插入新的数据元素\verb|e|。


	\item 删除元素：函数名称是\verb|ListDelete(L,i,e)|；初始条件是线性表\verb|L|已存在且非空，1≤\verb|i|≤\verb|ListLength(L)|；操作结果：删除\verb|L|的第\verb|i|个数据元素，用\verb|e|返回其值。


	\item 遍历表：函数名称是\verb|ListTraverse(L,visit())|，初始条件是线性表\verb|L|已存在；操作结果是依次对\verb|L|的每个数据元素调用函数\verb|visit()|。
\end{enumerate}
此外，还在基础功能的基础上实现了附加功能：
\begin{enumerate}

	\item 最大连续子数组和：函数名称是\verb|MaxSubArray(L)|；初始条件是线性表\verb|L|已存在且非空，请找出一个具有最大和的连续子数组（子数组最少包含一个元素），操作结果是其最大和；


	\item 和为\verb|K|的子数组：函数名称是\verb|SubArrayNum(L,k)|； 初始条件是线性表\verb|L|已存在且非空，操作结果是该数组中和为\verb|k|的连续子数组的个数；


	\item 顺序表排序：函数名称是\verb|sortList(L)|；初始条件是线性表\verb|L|已存在；操作结果是将\verb|L|由小到大排序；

	\item 实现线性表的文件形式保存：其中，
	\begin{itemize}
		\item 需要设计文件数据记录格式，以高效保存线性表数据逻辑结构\verb|(D,{R})|的完整信息；
		\item  需要设计线性表文件保存和加载操作合理模式。
	\end{itemize}

	\item 实现多个线性表管理：设计相应的数据结构管理多个线性表的查找、添加、移除等功能。
\end{enumerate}
实验目的：
\begin{enumerate}
	\item 加深对线性表的概念、基本运算的理解；
	\item 熟练掌握线性表的逻辑结构与物理结构的关系；
	\item 物理结构采用顺序表，熟练掌握线性表的基本运算的实现。
\end{enumerate}

\subsection{系统设计}
本系统提供一个采用顺序存储方式的线性表及其操作实现。
系统可供选择的操作有：
\begin{itemize}
	\item 基本操作：初始化线性表、销毁表、清空表、判定空表，求表长、获得元素、查找元素、获得某元素的前驱、获得某元素的后继、插入元素、删除元素、遍历线性表。
	\item 附加功能：最大连续子数组和、和为\verb|K|的子数组、顺序表排序、实现线性表的文件形式保存、实现多个线性表管理。
\end{itemize}

\subsubsection{头文件、宏和类型定义}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
#define ISEMPTY -3
#define LIST_INIT_SIZE 1000
#define LISTINCREMENT  10
#define max(i,j) ((i)>(j)?(i):(j))

typedef int status;
typedef int ElemType; //数据元素类型定义
typedef struct{  //顺序表（顺序结构）的定义
    ElemType * elem;
    int length;
    int listsize;
} SqList;

typedef struct THELISTS{  //顺序表的管理表定义
	 struct ALIST{
		 char name[30];
		 SqList L;
	  } elem[50];
	  int length = 0;
	  int listssize = 50;
 } LISTS;
\end{lstlisting}

\subsection{系统实现}


\subsection{系统测试}


\subsection{实验小结}

\newpage

\section{基于二叉链表的二叉树实现}


\subsection{问题描述}


\subsection{系统设计}


\subsection{系统实现}


\subsection{系统测试}

\subsection{实验小结}

\newpage

\section{课程的收获和建议}



\subsection{基于顺序存储结构的线性表实现}



\subsection{基于链式存储结构的线性表实现}



\subsection{基于二叉链表的二叉树实现}



\subsection{基于邻接表的图实现}


\section{附录A 基于顺序存储结构线性表实现的源程序}
\section{附录B 基于链式存储结构线性表实现的源程序}
\section{附录C 基于二叉链表二叉树实现的源程序}
\section{附录D 基于邻接表图实现的源程序}

\end{document}